name: Check reported version vs latest release

on:
  issues:
    types: [opened, edited, labeled]
  issue_comment:
    # include edited so users can add the version by editing their comment
    types: [created, edited]

permissions:
  issues: write
  contents: read
  models: read

concurrency:
  group: version-latest-check-${{ github.event.issue.number }}
  cancel-in-progress: true

jobs:
  check:
    if: >
      github.event.issue.pull_request == null && (
        (github.event_name == 'issues' && github.event.action == 'labeled' && github.event.label.name == 'bug') ||
        ((github.event_name != 'issues' || github.event.action != 'labeled') && contains(github.event.issue.labels.*.name, 'bug'))
      )
    runs-on: ubuntu-latest

    steps:
      - name: Extract version + compare with latest release (this repo)
        uses: actions/github-script@v7
        with:
          script: |
            const marker = '<!-- version-latest-check -->';

            function normalizeVersion(v) {
              if (!v) return '';
              return String(v)
                .trim()
                .replace(/^v/i, '')
                .replace(/[,\.\)\]\}]+$/g, '') // trim trailing punctuation
                .trim();
            }

            function isMissingOrPlaceholderVersion(v) {
              const n = normalizeVersion(v).toLowerCase();
              if (!n) return true;
              if (["n/a", "na", "unknown", "none", "-"].includes(n)) return true;
              if (/^(?:0+\.)+0+$/.test(n)) return true; // 0.0 / 0.0.0 / 0.0.0.0 ...
              return false;
            }

            // Accept ONLY: X.Y.Z (optionally prefixed with v) + optional prerelease/build
            // Examples: 1.2.3, v1.2.3, 10.30.40, 1.2.3-beta.1, 1.2.3+build
            const SEMVERISH = /^(?:v)?\d+\.\d+\.\d+(?:[-+][0-9A-Za-z\.-]+)?$/;

            function parseSemverish(v) {
              const n = normalizeVersion(v);
              const m = n.match(/(\d+)\.(\d+)\.(\d+)/); // require X.Y.Z
              if (!m) return null;
              return { major: +m[1], minor: +m[2], patch: +m[3] };
            }

            function cmp(a, b) {
              // -1 if a<b, 0 if equal, 1 if a>b
              if (!a || !b) return null;
              if (a.major !== b.major) return a.major < b.major ? -1 : 1;
              if (a.minor !== b.minor) return a.minor < b.minor ? -1 : 1;
              if (a.patch !== b.patch) return a.patch < b.patch ? -1 : 1;
              return 0;
            }

            function maxVersion(versions) {
              const filtered = (versions || [])
                .map(normalizeVersion)
                .filter(v => v && SEMVERISH.test(v) && !isMissingOrPlaceholderVersion(v));

              if (filtered.length === 0) return "";

              let best = filtered[0];
              for (const v of filtered.slice(1)) {
                const c = cmp(parseSemverish(best), parseSemverish(v));
                if (c === -1) best = v;
              }
              return best;
            }

            async function getLatestTagThisRepo() {
              const owner = context.repo.owner;
              const repo = context.repo.repo;

              // Primary: latest release (non-prerelease)
              try {
                const res = await github.rest.repos.getLatestRelease({ owner, repo });
                const tag = res?.data?.tag_name || '';
                const url = res?.data?.html_url || `https://github.com/${owner}/${repo}/releases/latest`;
                return { tag: normalizeVersion(tag), url, error: '' };
              } catch (e) {
                // Fallback: list releases (in case getLatestRelease 404s)
                try {
                  const rel = await github.rest.repos.listReleases({ owner, repo, per_page: 20 });
                  const releases = (rel?.data || []).filter(r => !r.draft);
                  const best = releases.find(r => !r.prerelease) || releases[0];
                  if (!best) throw new Error("No releases found");
                  const tag = best.tag_name || '';
                  const url = best.html_url || `https://github.com/${owner}/${repo}/releases`;
                  return { tag: normalizeVersion(tag), url, error: '' };
                } catch (e2) {
                  return { tag: '', url: '', error: `Could not fetch releases: ${e.message}; fallback failed: ${e2.message}` };
                }
              }
            }

            function safeJsonFromModel(raw) {
              const s0 = (raw || '').trim()
                .replace(/^\s*```(?:json)?\s*/i, '')
                .replace(/\s*```\s*$/i, '');
              const start = s0.indexOf('{');
              const end = s0.lastIndexOf('}');
              if (start === -1 || end === -1 || end <= start) return null;
              try { return JSON.parse(s0.slice(start, end + 1)); } catch { return null; }
            }

            // version core: ONLY X.Y.Z (+ optional prerelease/build), and not mid-match inside another dotted number
            const versionCore = String.raw`(?:v)?\d+\.\d+\.\d+(?:[-+][0-9A-Za-z\.-]+)?`;

            function extractVersionRegex(text) {
              const t = text || "";

              const kw = /(?:\bversion\b|\bver\b|\bv\.\b|\binstalled\b|\binstallation\b|\baddon\b|\bintegration\b|\bplugin\b|\bhacs\b|\brelease\b)/i;

              const near = new RegExp(
                String.raw`${kw.source}[^\n]{0,240}\b(?<!\.)(` + versionCore + String.raw`)\b`,
                'ig'
              );
              const before = new RegExp(
                String.raw`\b(?<!\.)(` + versionCore + String.raw`)\b[^\n]{0,120}${kw.source}`,
                'ig'
              );

              const candidates = [];
              for (const m of t.matchAll(near)) if (m?.[1]) candidates.push(m[1]);
              for (const m of t.matchAll(before)) if (m?.[1]) candidates.push(m[1]);

              if (candidates.length === 0) {
                const all = new RegExp(String.raw`\b(?<!\.)(` + versionCore + String.raw`)\b`, 'ig');
                for (const m of t.matchAll(all)) if (m?.[1]) candidates.push(m[1]);
              }

              return maxVersion(candidates);
            }

            async function extractVersionAI(text) {
              const payload = {
                model: "openai/gpt-4.1",
                temperature: 0,
                messages: [
                  {
                    role: "system",
                    content: [
                      "You extract ONE software version number from text.",
                      "",
                      "Return ONLY valid JSON with key:",
                      '- reported_version: string or ""',
                      "",
                      "Rules:",
                      "- If you are not sure, return empty string.",
                      "- Do NOT invent versions.",
                      "- Treat placeholders like 0.0.0, N/A, unknown as empty string.",
                      "- Accept ONLY versions like: 1.2.3, v1.2.3, 10.30.40, 1.2.3-beta.1, 1.2.3+build",
                      "- If the text only has 1.2 (two-part), return empty string.",
                      "- Prefer the version that refers to THIS repository's installation/integration.",
                      "- Ignore unrelated versions (e.g., Home Assistant core, OS, HACS, other addons).",
                    ].join("\n"),
                  },
                  { role: "user", content: text || "" },
                ],
              };

              const res = await fetch("https://models.github.ai/inference/chat/completions", {
                method: "POST",
                headers: {
                  Authorization: `Bearer ${process.env.GITHUB_TOKEN}`,
                  "Content-Type": "application/json",
                  Accept: "application/vnd.github+json",
                  "X-GitHub-Api-Version": "2022-11-28",
                },
                body: JSON.stringify(payload),
              });

              if (!res.ok) {
                core.warning(`Models API failed: ${res.status} ${res.statusText}`);
                return "";
              }

              const data = await res.json();
              const raw = (data?.choices?.[0]?.message?.content || "").trim();
              const obj = safeJsonFromModel(raw) || {};
              let v = normalizeVersion(obj.reported_version || "");

              if (!SEMVERISH.test(v) || isMissingOrPlaceholderVersion(v)) v = "";
              return v;
            }

            // --- Decide what to scan (comment vs body) ---
            const payload = context.payload;
            const issue = payload.issue;
            const issueNumber = issue.number;

            const BUG_LABEL = "bug";
            const labels = (issue.labels || [])
              .map(l => (typeof l === "string" ? l : l.name))
              .filter(Boolean);

            // Safety: only act on issues labeled as bug
            if (!labels.includes(BUG_LABEL)) return;

            const repoFull = `${context.repo.owner}/${context.repo.repo}`;

            // Fetch ALL comments once (used to prevent asking/checking multiple times)
            const allComments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              per_page: 100,
            });

            const missingSig = `Checked version: repo=${repoFull}, status=missing`;
            const alreadyAsked = (allComments || []).some(c =>
              (c.body || "").includes(marker) &&
              (c.body || "").includes(missingSig)
            );

            const alreadyChecked = (allComments || []).some(c => {
              const b = c.body || "";
              return b.includes(marker) &&
                b.includes(`Checked version: repo=${repoFull},`) &&
                /status=(outdated|latest|newer)\b/.test(b);
            });

            // If we've already done a version check once, do nothing forever after
            if (alreadyChecked) return;


            const bodyText = issue.body || "";
            let commentText = "";

            if (context.eventName === "issue_comment") {
              const comment = payload.comment;
              const creator = issue.user?.login;
              if (!comment || !creator) return;
              if (comment.user?.login !== creator) return; // only the issue creator
              commentText = comment.body || "";
            }

            let reported = "";

            if (context.eventName === "issue_comment") {
              // IMPORTANT: On comments, ONLY scan the comment. No fallback to issue body.
              reported = await extractVersionAI(commentText);
              if (!reported) reported = extractVersionRegex(commentText);
              if (!reported) return; // comment didn't contain a version => do nothing
            } else {
              // issues opened/edited: scan issue body
              reported = await extractVersionAI(bodyText);
              if (!reported) reported = extractVersionRegex(bodyText);

              if (!reported) {
                // Ask ONLY when it becomes a bug issue (opened with bug label OR bug label just got added), and only once
                const shouldAskNow =
                  context.eventName === "issues" &&
                  (payload.action === "opened" || (payload.action === "labeled" && payload.label?.name === BUG_LABEL));

                if (!shouldAskNow) return;
                if (alreadyAsked) return;

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: [
                    marker,
                    missingSig,
                    "",
                    "Hi! I couldn't find a version number in the issue description.",
                    "Please reply with the version you're running in `X.Y.Z` format (e.g. `3.1.1`) or with a `v` prefix (e.g. `v3.1.1`).",
                    "",
                    "Thanks üôè"
                  ].join("\n"),
                });

                return;
              }
            }

            // Fetch latest release for THIS repo
            const latest = await getLatestTagThisRepo();
            if (!latest.tag) return;

            const vCmp = cmp(parseSemverish(reported), parseSemverish(latest.tag));
            if (vCmp === null) return;

            const status =
              vCmp === -1 ? "outdated" :
              vCmp ===  0 ? "latest" :
                           "newer";

            // Avoid duplicate comment in case of re-runs (we only want ONE check total)
            const signatureLine = `Checked version: repo=${repoFull}, reported=${reported}, latest=${latest.tag}, status=${status}`;
            const already = (allComments || []).some(c => {
              const b = c.body || "";
              return b.includes(marker) && b.includes(signatureLine);
            });
            if (already) return;


            const lines = [marker, signatureLine, ""];

            if (status === "outdated") {
              lines.push(
                "Hi! It looks like your installation is not on the latest release.",
                "Please update to the latest version and try again. If the issue still happens afterwards, reply here with the results.",
                "",
                `- You have: \`${reported}\` ‚ùå`,
                `- Latest release: \`${latest.tag}\` ‚Äî ${latest.url}`,
                "",
                "Thanks üôè"
              );
            } else if (status === "latest") {
              lines.push(
                "Thanks! Your version looks up to date ‚úÖ",
                "",
                `- You have: \`${reported}\` ‚úÖ`,
                `- Latest release: \`${latest.tag}\` ‚Äî ${latest.url}`,
                "",
                "If the issue still happens, please share steps to reproduce and any relevant logs/screenshots. üôè"
              );
            } else {
              lines.push(
                "Note: Your reported version looks newer than the latest GitHub release.",
                "If you're on a dev/pre-release build, that's fine ‚Äî otherwise please double-check the version number.",
                "",
                `- You have: \`${reported}\` ‚ö†Ô∏è`,
                `- Latest release: \`${latest.tag}\` ‚Äî ${latest.url}`,
                "",
                "Thanks üôè"
              );
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: lines.join("\n"),
            });
