name: Check reported version vs latest release

on:
  issues:
    types: [opened, edited]
  issue_comment:
    types: [created, edited]

permissions:
  issues: write
  contents: read
  models: read

jobs:
  check:
    if: github.event.issue.pull_request == null
    runs-on: ubuntu-latest

    steps:
      - name: Extract version + compare with latest release (this repo)
        uses: actions/github-script@v7
        with:
          script: |
            const marker = '<!-- version-latest-check -->';

            function normalizeVersion(v) {
              if (!v) return '';
              return String(v)
                .trim()
                .replace(/^v/i, '')
                .replace(/[,\.\)\]\}]+$/g, '') // trim trailing punctuation
                .trim();
            }

            function isMissingOrPlaceholderVersion(v) {
              const n = normalizeVersion(v).toLowerCase();
              if (!n) return true;
              if (["n/a", "na", "unknown", "none", "-"].includes(n)) return true;
              if (/^(?:0+\.)+0+$/.test(n)) return true; // 0.0 / 0.0.0 / ...
              return false;
            }

            // Accept: 1.2, 1.2.3, v1.2.3, 1.2.3-beta.1, 1.2.3+build
            const SEMVERISH = /^(?:v)?\d+\.\d+(?:\.\d+)?(?:[-+][0-9A-Za-z\.-]+)?$/;

            function parseSemverish(v) {
              const n = normalizeVersion(v);
              const m = n.match(/(\d+)\.(\d+)(?:\.(\d+))?/);
              if (!m) return null;
              return { major: +m[1], minor: +m[2], patch: +(m[3] ?? 0) };
            }

            function cmp(a, b) {
              // -1 if a<b, 0 if equal, 1 if a>b
              if (!a || !b) return null;
              if (a.major !== b.major) return a.major < b.major ? -1 : 1;
              if (a.minor !== b.minor) return a.minor < b.minor ? -1 : 1;
              if (a.patch !== b.patch) return a.patch < b.patch ? -1 : 1;
              return 0;
            }

            function maxVersion(versions) {
              const filtered = (versions || [])
                .map(normalizeVersion)
                .filter(v => v && SEMVERISH.test(v) && !isMissingOrPlaceholderVersion(v));

              if (filtered.length === 0) return "";

              let best = filtered[0];
              for (const v of filtered.slice(1)) {
                const c = cmp(parseSemverish(best), parseSemverish(v));
                if (c === -1) best = v;
              }
              return best;
            }

            async function getLatestTagThisRepo() {
              const owner = context.repo.owner;
              const repo = context.repo.repo;

              // Primary: latest release (non-prerelease)
              try {
                const res = await github.rest.repos.getLatestRelease({ owner, repo });
                const tag = res?.data?.tag_name || '';
                const url = res?.data?.html_url || `https://github.com/${owner}/${repo}/releases/latest`;
                return { tag: normalizeVersion(tag), url, error: '' };
              } catch (e) {
                // Fallback: list releases (in case getLatestRelease 404s)
                try {
                  const rel = await github.rest.repos.listReleases({ owner, repo, per_page: 20 });
                  const releases = (rel?.data || []).filter(r => !r.draft);
                  // pick first non-prerelease if possible, otherwise first release
                  const best = releases.find(r => !r.prerelease) || releases[0];
                  if (!best) throw new Error("No releases found");
                  const tag = best.tag_name || '';
                  const url = best.html_url || `https://github.com/${owner}/${repo}/releases`;
                  return { tag: normalizeVersion(tag), url, error: '' };
                } catch (e2) {
                  return { tag: '', url: '', error: `Could not fetch releases: ${e.message}; fallback failed: ${e2.message}` };
                }
              }
            }

            function safeJsonFromModel(raw) {
              const s0 = (raw || '').trim()
                .replace(/^\s*```(?:json)?\s*/i, '')
                .replace(/\s*```\s*$/i, '');
              const start = s0.indexOf('{');
              const end = s0.lastIndexOf('}');
              if (start === -1 || end === -1 || end <= start) return null;
              try { return JSON.parse(s0.slice(start, end + 1)); } catch { return null; }
            }

            // version core:
            // - allows 1.2.3 or 1.2 (but not partial matches inside 1.0.2 like "0.2")
            // - we enforce: NOT preceded by a dot (so we can't start mid-version)
            const versionCore = String.raw`(?:v)?(?:\d+\.\d+\.\d+|\d+\.\d+(?!\.\d))(?:[-+][0-9A-Za-z\.-]+)?`;

            function extractVersionRegex(text) {
              const t = text || "";

              // Try to find versions near typical "version" words first
              const kw = /(?:\bversion\b|\bver\b|\bv\.\b|\binstalled\b|\binstallation\b|\baddon\b|\bintegration\b|\bplugin\b|\bhacs\b|\brelease\b)/i;

              const near = new RegExp(
                String.raw`${kw.source}[^\n]{0,240}\b(?<!\.)(` + versionCore + String.raw`)\b`,
                'ig'
              );
              const before = new RegExp(
                String.raw`\b(?<!\.)(` + versionCore + String.raw`)\b[^\n]{0,120}${kw.source}`,
                'ig'
              );

              const candidates = [];
              for (const m of t.matchAll(near)) if (m?.[1]) candidates.push(m[1]);
              for (const m of t.matchAll(before)) if (m?.[1]) candidates.push(m[1]);

              // Fallback: if nothing near keywords, grab all semverish and pick the highest
              if (candidates.length === 0) {
                const all = new RegExp(String.raw`\b(?<!\.)(` + versionCore + String.raw`)\b`, 'ig');
                for (const m of t.matchAll(all)) if (m?.[1]) candidates.push(m[1]);
              }

              return maxVersion(candidates);
            }

            async function extractVersionAI(text) {
              const payload = {
                model: "openai/gpt-4.1",
                temperature: 0,
                messages: [
                  {
                    role: "system",
                    content: [
                      "You extract ONE software version number from text.",
                      "",
                      "Return ONLY valid JSON with key:",
                      '- reported_version: string or ""',
                      "",
                      "Rules:",
                      "- If you are not sure, return empty string.",
                      "- Do NOT invent versions.",
                      "- Treat placeholders like 0.0, 0.0.0, N/A, unknown as empty string.",
                      "- Accept versions like: 1.2, 1.2.3, v1.2.3, 1.2.3-beta.1",
                      "- Prefer the version that refers to THIS repository's installation/integration.",
                      "- Ignore unrelated versions (e.g., Home Assistant core, OS, HACS, other addons).",
                    ].join("\n"),
                  },
                  { role: "user", content: text || "" },
                ],
              };

              const res = await fetch("https://models.github.ai/inference/chat/completions", {
                method: "POST",
                headers: {
                  Authorization: `Bearer ${process.env.GITHUB_TOKEN}`,
                  "Content-Type": "application/json",
                  Accept: "application/vnd.github+json",
                  "X-GitHub-Api-Version": "2022-11-28",
                },
                body: JSON.stringify(payload),
              });

              if (!res.ok) {
                core.warning(`Models API failed: ${res.status} ${res.statusText}`);
                return "";
              }

              const data = await res.json();
              const raw = (data?.choices?.[0]?.message?.content || "").trim();
              const obj = safeJsonFromModel(raw) || {};
              let v = normalizeVersion(obj.reported_version || "");

              if (!SEMVERISH.test(v) || isMissingOrPlaceholderVersion(v)) v = "";
              return v;
            }

            // --- Decide what to scan (prefer comment, fill from body) ---
            const payload = context.payload;
            const issue = payload.issue;
            const issueNumber = issue.number;

            const bodyText = issue.body || "";
            let commentText = "";

            if (context.eventName === "issue_comment") {
              const comment = payload.comment;
              const creator = issue.user?.login;
              if (!comment || !creator) return;
              if (comment.user?.login !== creator) return; // only the issue creator
              commentText = comment.body || "";
            }

            // Extract reported version (prefer comment, then body)
            let reported = "";

            if (commentText) {
              reported = await extractVersionAI(commentText);
              if (!reported) reported = extractVersionRegex(commentText);
            }

            if (!reported) {
              reported = await extractVersionAI(bodyText);
              if (!reported) reported = extractVersionRegex(bodyText);
            }

            if (!reported) return;

            // Fetch latest release for THIS repo
            const latest = await getLatestTagThisRepo();
            if (!latest.tag) return;

            const vCmp = cmp(parseSemverish(reported), parseSemverish(latest.tag));
            if (vCmp === null) return;

            const status =
              vCmp === -1 ? "outdated" :
              vCmp ===  0 ? "latest" :
                           "newer";

            // Avoid duplicate comments for same (reported + latest + status)
            const existingComments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              per_page: 100,
            });

            const repoFull = `${context.repo.owner}/${context.repo.repo}`;
            const signatureLine = `Checked version: repo=${repoFull}, reported=${reported}, latest=${latest.tag}, status=${status}`;

            const already = (existingComments.data || []).some(c =>
              (c.body || "").includes(marker) &&
              (c.body || "").includes(`repo=${repoFull}`) &&
              (c.body || "").includes(`reported=${reported}`) &&
              (c.body || "").includes(`latest=${latest.tag}`) &&
              (c.body || "").includes(`status=${status}`)
            );
            if (already) return;

            const lines = [marker, signatureLine, ""];

            if (status === "outdated") {
              lines.push(
                "Hi! It looks like your installation is not on the latest release.",
                "Please update to the latest version and try again. If the issue still happens afterwards, reply here with the results.",
                "",
                `- You have: \`${reported}\` âŒ`,
                `- Latest release: \`${latest.tag}\` â€” ${latest.url}`,
                "",
                "Thanks ğŸ™"
              );
            } else if (status === "latest") {
              lines.push(
                "Thanks! Your version looks up to date âœ…",
                "",
                `- You have: \`${reported}\` âœ…`,
                `- Latest release: \`${latest.tag}\` â€” ${latest.url}`,
                "",
                "If the issue still happens, please share steps to reproduce and any relevant logs/screenshots. ğŸ™"
              );
            } else {
              lines.push(
                "Note: Your reported version looks newer than the latest GitHub release.",
                "If you're on a dev/pre-release build, that's fine â€” otherwise please double-check the version number.",
                "",
                `- You have: \`${reported}\` âš ï¸`,
                `- Latest release: \`${latest.tag}\` â€” ${latest.url}`,
                "",
                "Thanks ğŸ™"
              );
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: lines.join("\n"),
            });
