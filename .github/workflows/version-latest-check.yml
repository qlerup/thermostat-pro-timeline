name: Check reported version vs latest release

on:
  issues:
    types: [opened, edited]
  issue_comment:
    types: [created, edited]

permissions:
  issues: write
  contents: read
  models: read

jobs:
  check:
    if: github.event.issue.pull_request == null
    runs-on: ubuntu-latest

    steps:
      - name: Extract version + compare with latest release (this repo)
        uses: actions/github-script@v7
        with:
          script: |
            const marker = '<!-- version-latest-check -->';

            function normalizeVersion(v) {
              if (!v) return '';
              return String(v)
                .trim()
                .replace(/^v/i, '')
                .replace(/[,\.\)\]\}]+$/g, '') // trim trailing punctuation
                .trim();
            }

            function isMissingOrPlaceholderVersion(v) {
              const n = normalizeVersion(v).toLowerCase();
              if (!n) return true;
              if (["n/a", "na", "unknown", "none", "-"].includes(n)) return true;
              if (/^(?:0+\.)+0+$/.test(n)) return true; // 0.0 / 0.0.0 / 0.0.0.0 ...
              return false;
            }

            // Accept ONLY: X.Y.Z (optionally prefixed with v) + optional prerelease/build
            // Examples: 1.2.3, v1.2.3, 10.30.40, 1.2.3-beta.1, 1.2.3+build
            const SEMVERISH = /^(?:v)?\d+\.\d+\.\d+(?:[-+][0-9A-Za-z\.-]+)?$/;

            function parseSemverish(v) {
              const n = normalizeVersion(v);
              const m = n.match(/(\d+)\.(\d+)\.(\d+)/); // require X.Y.Z
              if (!m) return null;
              return { major: +m[1], minor: +m[2], patch: +m[3] };
            }

            function cmp(a, b) {
              // -1 if a<b, 0 if equal, 1 if a>b
              if (!a || !b) return null;
              if (a.major !== b.major) return a.major < b.major ? -1 : 1;
              if (a.minor !== b.minor) return a.minor < b.minor ? -1 : 1;
              if (a.patch !== b.patch) return a.patch < b.patch ? -1 : 1;
              return 0;
            }

            function maxVersion(versions) {
              const filtered = (versions || [])
                .map(normalizeVersion)
                .filter(v => v && SEMVERISH.test(v) && !isMissingOrPlaceholderVersion(v));

              if (filtered.length === 0) return "";

              let best = filtered[0];
              for (const v of filtered.slice(1)) {
                const c = cmp(parseSemverish(best), parseSemverish(v));
                if (c === -1) best = v;
              }
              return best;
            }

            async function getLatestTagThisRepo() {
              const owner = context.repo.owner;
              const repo = context.repo.repo;

              // Primary: latest release (non-prerelease)
              try {
                const res = await github.rest.repos.getLatestRelease({ owner, repo });
                const tag = res?.data?.tag_name || '';
                const url = res?.data?.html_url || `https://github.com/${owner}/${repo}/releases/latest`;
                return { tag: normalizeVersion(tag), url, error: '' };
              } catch (e) {
                // Fallback: list releases (in case getLatestRelease 404s)
                try {
                  const rel = await github.rest.repos.listReleases({ owner, repo, per_page: 20 });
                  const releases = (rel?.data || []).filter(r => !r.draft);
                  const best = releases.find(r => !r.prerelease) || releases[0];
                  if (!best) throw new Error("No releases found");
                  const tag = best.tag_name || '';
                  const url = best.html_url || `https://github.com/${owner}/${repo}/releases`;
                  return { tag: normalizeVersion(tag), url, error: '' };
                } catch (e2) {
                  return { tag: '', url: '', error: `Could not fetch releases: ${e.message}; fallback failed: ${e2.message}` };
                }
              }
            }

            function safeJsonFromModel(raw) {
              const s0 = (raw || '').trim()
                .replace(/^\s*```(?:json)?\s*/i, '')
                .replace(/\s*```\s*$/i, '');
              const start = s0.indexOf('{');
              const end = s0.lastIndexOf('}');
              if (start === -1 || end === -1 || end <= start) return null;
              try { return JSON.parse(s0.slice(start, end + 1)); } catch { return null; }
            }

            // version core: ONLY X.Y.Z (+ optional prerelease/build), and not mid-match inside another dotted number
            const versionCore = String.raw`(?:v)?\d+\.\d+\.\d+(?:[-+][0-9A-Za-z\.-]+)?`;

            function extractVersionRegex(text) {
              const t = text || "";

              const kw = /(?:\bversion\b|\bver\b|\bv\.\b|\binstalled\b|\binstallation\b|\baddon\b|\bintegration\b|\bplugin\b|\bhacs\b|\brelease\b)/i;

              const near = new RegExp(
                String.raw`${kw.source}[^\n]{0,240}\b(?<!\.)(` + versionCore + String.raw`)\b`,
                'ig'
              );
              const before = new RegExp(
                String.raw`\b(?<!\.)(` + versionCore + String.raw`)\b[^\n]{0,120}${kw.source}`,
                'ig'
              );

              const candidates = [];
              for (const m of t.matchAll(near)) if (m?.[1]) candidates.push(m[1]);
              for (const m of t.matchAll(before)) if (m?.[1]) candidates.push(m[1]);

              if (candidates.length === 0) {
                const all = new RegExp(String.raw`\b(?<!\.)(` + versionCore + String.raw`)\b`, 'ig');
                for (const m of t.matchAll(all)) if (m?.[1]) candidates.push(m[1]);
              }

              return maxVersion(candidates);
            }

            async function extractVersionAI(text) {
              const payload = {
                model: "openai/gpt-4.1",
                temperature: 0,
                messages: [
                  {
                    role: "system",
                    content: [
                      "You extract ONE software version number from text.",
                      "",
                      "Return ONLY valid JSON with key:",
                      '- reported_version: string or ""',
                      "",
                      "Rules:",
                      "- If you are not sure, return empty string.",
                      "- Do NOT invent versions.",
                      "- Treat placeholders like 0.0.0, N/A, unknown as empty string.",
                      "- Accept ONLY versions like: 1.2.3, v1.2.3, 10.30.40, 1.2.3-beta.1, 1.2.3+build",
                      "- If the text only has 1.2 (two-part), return empty string.",
                      "- Prefer the version that refers to THIS repository's installation/integration.",
                      "- Ignore unrelated versions (e.g., Home Assistant core, OS, HACS, other addons).",
                    ].join("\n"),
                  },
                  { role: "user", content: text || "" },
                ],
              };

              const res = await fetch("https://models.github.ai/inference/chat/completions", {
                method: "POST",
                headers: {
                  Authorization: `Bearer ${process.env.GITHUB_TOKEN}`,
                  "Content-Type": "application/json",
                  Accept: "application/vnd.github+json",
                  "X-GitHub-Api-Version": "2022-11-28",
                },
                body: JSON.stringify(payload),
              });

              if (!res.ok) {
                core.warning(`Models API failed: ${res.status} ${res.statusText}`);
                return "";
              }

              const data = await res.json();
              const raw = (data?.choices?.[0]?.message?.content || "").trim();
              const obj = safeJsonFromModel(raw) || {};
              let v = normalizeVersion(obj.reported_version || "");

              if (!SEMVERISH.test(v) || isMissingOrPlaceholderVersion(v)) v = "";
              return v;
            }

            // --- Decide what to scan (comment vs body) ---
            const payload = context.payload;
            const issue = payload.issue;
            const issueNumber = issue.number;

            const bodyText = issue.body || "";
            let commentText = "";

            if (context.eventName === "issue_comment") {
              const comment = payload.comment;
              const creator = issue.user?.login;
              if (!comment || !creator) return;
              if (comment.user?.login !== creator) return; // only the issue creator
              commentText = comment.body || "";
            }

            let reported = "";

            if (context.eventName === "issue_comment") {
              // IMPORTANT: On comments, ONLY scan the comment. No fallback to issue body.
              reported = await extractVersionAI(commentText);
              if (!reported) reported = extractVersionRegex(commentText);
              if (!reported) return; // comment didn't contain a version => do nothing
            } else {
              // issues opened/edited: scan issue body
              reported = await extractVersionAI(bodyText);
              if (!reported) reported = extractVersionRegex(bodyText);

              if (!reported) {
                // Ask ONLY on issue creation (opened), and only once
                if (payload.action !== "opened") return;

                const existingComments = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  per_page: 100,
                });

                const repoFull = `${context.repo.owner}/${context.repo.repo}`;
                const missingSig = `Checked version: repo=${repoFull}, status=missing`;

                const alreadyAsked = (existingComments.data || []).some(c =>
                  (c.body || "").includes(marker) &&
                  (c.body || "").includes(missingSig)
                );
                if (alreadyAsked) return;

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: [
                    marker,
                    missingSig,
                    "",
                    "Hej! Jeg kan ikke se nogen version i din issue-beskrivelse.",
                    "Skriv venligst hvilken version du k√∏rer i formatet `vX.Y.Z` eller `X.Y.Z` (fx `v10.30.40`).",
                    "",
                    "Tak üôè"
                  ].join("\n"),
                });

                return;
              }
            }

            // Fetch latest release for THIS repo
            const latest = await getLatestTagThisRepo();
            if (!latest.tag) return;

            const vCmp = cmp(parseSemverish(reported), parseSemverish(latest.tag));
            if (vCmp === null) return;

            const status =
              vCmp === -1 ? "outdated" :
              vCmp ===  0 ? "latest" :
                           "newer";

            // Avoid duplicate comments for same (reported + latest + status)
            const existingComments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              per_page: 100,
            });

            const repoFull = `${context.repo.owner}/${context.repo.repo}`;
            const signatureLine = `Checked version: repo=${repoFull}, reported=${reported}, latest=${latest.tag}, status=${status}`;

            const already = (existingComments.data || []).some(c =>
              (c.body || "").includes(marker) &&
              (c.body || "").includes(`repo=${repoFull}`) &&
              (c.body || "").includes(`reported=${reported}`) &&
              (c.body || "").includes(`latest=${latest.tag}`) &&
              (c.body || "").includes(`status=${status}`)
            );
            if (already) return;

            const lines = [marker, signatureLine, ""];

            if (status === "outdated") {
              lines.push(
                "Hi! It looks like your installation is not on the latest release.",
                "Please update to the latest version and try again. If the issue still happens afterwards, reply here with the results.",
                "",
                `- You have: \`${reported}\` ‚ùå`,
                `- Latest release: \`${latest.tag}\` ‚Äî ${latest.url}`,
                "",
                "Thanks üôè"
              );
            } else if (status === "latest") {
              lines.push(
                "Thanks! Your version looks up to date ‚úÖ",
                "",
                `- You have: \`${reported}\` ‚úÖ`,
                `- Latest release: \`${latest.tag}\` ‚Äî ${latest.url}`,
                "",
                "If the issue still happens, please share steps to reproduce and any relevant logs/screenshots. üôè"
              );
            } else {
              lines.push(
                "Note: Your reported version looks newer than the latest GitHub release.",
                "If you're on a dev/pre-release build, that's fine ‚Äî otherwise please double-check the version number.",
                "",
                `- You have: \`${reported}\` ‚ö†Ô∏è`,
                `- Latest release: \`${latest.tag}\` ‚Äî ${latest.url}`,
                "",
                "Thanks üôè"
              );
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: lines.join("\n"),
            });
